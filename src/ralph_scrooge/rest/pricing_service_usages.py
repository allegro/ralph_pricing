# -*- coding: utf-8 -*-

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import datetime
import json
import logging
from collections import defaultdict

from django.http import HttpResponse
from rest_framework import status
from rest_framework import serializers
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.serializers import Serializer

from ralph_scrooge.models import (
    DailyUsage,
    PricingObject,
    PricingService,
    ServiceEnvironment,
    UsageType,
)

logger = logging.getLogger(__name__)


class UsageObject(object):
    symbol = None
    value = None

    def __init__(self, symbol=None, value=None, **kwargs):
        self.symbol = symbol
        self.value = value


class UsageObjectSerializer(Serializer):
    symbol = serializers.CharField()
    value = serializers.FloatField()


class UsageObjectDeserializer(UsageObjectSerializer):
    """Dummy class provided only for symmetry."""
    pass


class UsagesObject(object):
    service = None
    service_id = None
    service_uid = None
    environment = None
    pricing_object = None
    usages = []  # list of UsageObject

    def __init__(
        self,
        service=None,
        service_id=None,
        service_uid=None,
        environment=None,
        pricing_object=None,
        usages=None,
        **kwargs
    ):
        self.service = service
        self.service_id = service_id
        self.service_uid = service_uid
        self.environment = environment
        self.pricing_object = pricing_object
        self.usages = usages or []


class UsagesObjectSerializer(Serializer):
    service = serializers.CharField()
    service_id = serializers.IntegerField()
    service_uid = serializers.CharField()
    environment = serializers.CharField()
    pricing_object = serializers.CharField()
    usages = UsageObjectSerializer(many=True)

    class Meta:
        model = UsagesObject  # XXX needed..?
        exclude = ('service_uid',)


class UsagesObjectDeserializer(UsagesObjectSerializer):
    service = serializers.CharField(required=False)
    service_id = serializers.IntegerField(required=False)
    service_uid = serializers.CharField(required=False)
    environment = serializers.CharField(required=False)
    pricing_object = serializers.CharField(required=False)
    usages = UsageObjectDeserializer(many=True)

    # XXX The presence of this method breaks deserialization of nested objects - WTF??
    # def validate(self, usages_obj):
    #     # TODO(xor-xor): Get rid of "non_field_errors" header from error
    #     # message generated by DjRF.
    #     pricing_obj = usages_obj.get('pricing_object')
    #     service = usages_obj.get('service')
    #     service_id = usages_obj.get('service_id')
    #     service_uid = usages_obj.get('service_uid')
    #     env = usages_obj.get('environment')
    #     err = None

    #     if pricing_obj and any((service, service_id, service_uid, env)):
    #         err = ("pricing_object shouldn't be used with any of: "
    #                 "service, service_id, service_uid, environment")
    #     elif service and any((service_id, service_uid)):
    #         err = ("service shouldn't be used with any of: "
    #                 "service_id, service_uid")
    #     elif service_id and service_uid:
    #         err = "service_id shouldn't be used with service_uid"
    #     elif env and not any((service, service_id, service_uid)):
    #         err = ("environment requires service or service_id or "
    #                 "service_uid")

    #     if err is not None:
    #         msg = "Invalid combination of fields: {}.".format(err)
    #         raise serializers.ValidationError(msg)


class PricingServiceUsageObject(object):
    pricing_service = None
    pricing_service_id = None
    date = None
    overwrite = None
    usages = []  # list of UsagesObject

    def __init__(
        self,
        pricing_service=None,
        pricing_service_id=None,
        usages=None,
        date=None,
        overwrite=None,
        **kwargs
    ):
        self.pricing_service = pricing_service
        self.pricing_service_id = pricing_service_id
        self.date = date
        self.usages = usages or []
        self.overwrite = overwrite or 'no'


class PricingServiceUsageObjectSerializer(Serializer):
    pricing_service = serializers.CharField()
    pricing_service_id = serializers.IntegerField()
    date = serializers.DateField()
    overwrite = serializers.CharField()
    usages = UsagesObjectSerializer(many=True)

    class Meta:
        model = PricingServiceUsageObject  # XXX needed..?
        exclude = ('overwrite',)


class PricingServiceUsageObjectDeserializer(PricingServiceUsageObjectSerializer):  # noqa
    overwrite = serializers.CharField(required=False, default='no')
    usages = UsagesObjectDeserializer(many=True)

    def validate_overwrite(self, attrs, source):
        value = attrs[source]
        if value not in ('no', 'delete_all_previous', 'values_only'):
            raise serializers.ValidationError(
                "Invalid value: {}".format(value)
            )
        return attrs

    def validate_pricing_service(self, attrs, source):
        value = attrs[source]
        try:
            PricingService.objects.get(name=value)
        except PricingService.DoesNotExist:
            raise serializers.ValidationError(
                "Unknown service name: {}".format(value)
            )
        return attrs

    class Meta:
        model = PricingServiceUsageObject  # XXX needed..?
        exclude = ('pricing_service_id',)


class PricingServiceUsages(APIView):

    def get(self, request, usages_date, pricing_service_id, *args, **kwargs):
        try:
            PricingService.objects.get(id=pricing_service_id)
        except PricingService.DoesNotExist:
            msg = (
                "Service with ID {} does not exist.".format(pricing_service_id)
            )
            return Response({'error': msg}, status=status.HTTP_400_BAD_REQUEST)
        result = self.get_usages(usages_date, pricing_service_id)
        return Response(PricingServiceUsageObjectSerializer(result).data)

    def post(self, request, *args, **kwargs):
        deserializer = PricingServiceUsageObjectDeserializer(data=request.DATA)
        if deserializer.is_valid():
            self.save_usages(deserializer.object)
            return HttpResponse(status=201)
        return Response(deserializer.errors, status=400)

    def get_usages(self, usages_date, pricing_service_id):
        pricing_service = PricingService.objects.get(  # XXX objects_admin..?
            id=pricing_service_id,
        )
        ps = PricingServiceUsageObject(
            pricing_service=pricing_service.name,
            date=usages_date,
            usages=[],
        )
        usages_dict = defaultdict(list)

        # iterate through pricing service usage types
        for usage_type in pricing_service.usage_types.all():
            daily_usages = usage_type.dailyusage_set.filter(
                date=usages_date
            ).select_related(
                'service_environment',
                'service_environment__service',
                'service_environment__environment',
                'pricing_object'
            )
            for daily_usage in daily_usages:
                usages_dict[daily_usage.daily_pricing_object].append(
                    (daily_usage.type.symbol, daily_usage.value)
                )

        # save usages tp UsagesObjects
        for dpo, u in usages_dict.iteritems():
            usages = UsagesObject()
            se = dpo.service_environment
            usages.service = se.service.name
            usages.service_id = se.service.id
            usages.environment = se.environment.name
            # if pricing object is not dummy pricing object for service
            # environment use it
            if se.dummy_pricing_object != dpo.pricing_object:
                usages.pricing_object = dpo.pricing_object.name
            usages.usages = [UsageObject(k, v) for k, v in u]
            ps.usages.append(usages)
        return ps

    def get_service_env(self, usages):
        se_params = {
            'environment__name': usages.get('environment'),
        }
        if usages.service_id:
            se_params['service_id'] = usages['service_id']
        elif usages.service_uid:
            se_params['service__ci_uid'] = usages['service_uid']
        else:
            se_params['service__name'] = usages['service']
        return ServiceEnvironment.objects.get(**se_params)  # XXX try/except

    def remove_previous_daily_usages(self, overwrite, date, usages_dp_objs):
        if overwrite in ('values_only', 'delete_all_previous'):
            logger.debug('Remove previous values ({})'.format(overwrite))
            for k, v in usages_dp_objs.iteritems():
                previuos_usages = DailyUsage.objects.filter(date=date, type=k)
                if overwrite == 'values_only':
                    previuos_usages = previuos_usages.filter(
                        daily_pricing_object__in=v
                    )
                previuos_usages.delete()

    def get_pricing_object(self, usages):
        if usages.get('pricing_object'):
            pricing_object = PricingObject.objects.get(
                name=usages['pricing_object'],
            )  # XXX try/except
        else:
            if not usages.get('environment') or not any([
                usages.get('service_id'),
                usages.get('service'),
                usages.get('service_uid'),
            ]):
                pass
                # XXX raise some exception here
            else:
                service_env = self.get_service_env(usages)
                pricing_object = service_env.dummy_pricing_object  # XXX what is dummy_pricing_object?
        return pricing_object

    def get_usages_for_save(self, pricing_service_usage):
        usage_types = {}  # XXX there's such empty dict in old API's code
        daily_usages = []
        usages_daily_pricing_objects = defaultdict(list)

        for usages in pricing_service_usage['usages']:
            pricing_object = self.get_pricing_object(usages)
            for usage in usages['usages']:
                usage_type = usage_types.get(
                    usage['symbol'],
                    UsageType.objects_admin.get(symbol=usage['symbol'])  # XXX try/except
                )
                daily_pricing_object = (
                    pricing_object.get_daily_pricing_object(
                        pricing_service_usage['date']
                    )
                )
                daily_usage = DailyUsage(
                    date=pricing_service_usage['date'],
                    type=usage_type,
                    value=usage['value'],
                    daily_pricing_object=daily_pricing_object,
                    service_environment=(
                        daily_pricing_object.service_environment
                    ),
                )
                daily_usages.append(daily_usage)
                usages_daily_pricing_objects[usage_type].append(
                    daily_pricing_object
                )
        return (daily_usages, usages_daily_pricing_objects)

    def save_usages(self, pricing_service_usage):
        logger.info("Saving usages for service {}".format(
            pricing_service_usage['pricing_service']
        ))
        daily_usages, usages_daily_pricing_objects = self.get_usages_for_save(
            pricing_service_usage
        )
        self.remove_previous_daily_usages(
            pricing_service_usage['overwrite'],
            pricing_service_usage['date'],
            usages_daily_pricing_objects,
        )
        DailyUsage.objects.bulk_create(daily_usages)

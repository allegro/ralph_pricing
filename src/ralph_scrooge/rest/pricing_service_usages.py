# -*- coding: utf-8 -*-

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import datetime
import json
import logging
from collections import defaultdict

from django.http import HttpResponse
from rest_framework import status
from rest_framework import serializers
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.serializers import Serializer

from ralph_scrooge.models import (
    DailyUsage,
    PricingObject,
    PricingService,
    ServiceEnvironment,
    UsageType,
)

logger = logging.getLogger(__name__)


# TODO(xor-xor): Consider moving *all* exceptions used by Scrooge into single
# module.
class ServiceEnvironmentDoesNotExistError(Exception):
    pass


class UsageObject(object):
    symbol = None
    value = None

    def __init__(self, symbol=None, value=None, **kwargs):
        self.symbol = symbol
        self.value = value


class UsageObjectSerializer(Serializer):
    symbol = serializers.CharField()
    value = serializers.FloatField()


class UsageObjectDeserializer(UsageObjectSerializer):

    def validate(self, attrs):
        if not UsageType.objects.filter(symbol=attrs['symbol']).exists():
            err = (
                'usage type for symbol "{}" does not exist'
                .format(attrs['symbol'])
            )
            raise serializers.ValidationError(err)
        return attrs



class UsagesObject(object):
    service = None
    service_id = None
    service_uid = None
    environment = None
    pricing_object = None
    usages = []  # list of UsageObject

    def __init__(
        self,
        service=None,
        service_id=None,
        service_uid=None,
        environment=None,
        pricing_object=None,
        usages=None,
        **kwargs
    ):
        self.service = service
        self.service_id = service_id
        self.service_uid = service_uid
        self.environment = environment
        self.pricing_object = pricing_object
        self.usages = usages or []


class UsagesObjectSerializer(Serializer):
    service = serializers.CharField()
    service_id = serializers.IntegerField()
    service_uid = serializers.CharField()
    environment = serializers.CharField()
    pricing_object = serializers.CharField()
    usages = UsageObjectSerializer(many=True)

    class Meta:
        model = UsagesObject  # XXX needed..?
        exclude = ('service_uid',)



class UsagesObjectDeserializer(UsagesObjectSerializer):
    service = serializers.CharField(required=False)
    service_id = serializers.IntegerField(required=False)
    service_uid = serializers.CharField(required=False)
    environment = serializers.CharField(required=False)
    pricing_object = serializers.CharField(required=False)
    usages = UsageObjectDeserializer(many=True)


    def _get_service_env(self, attrs):
        se_params = {
            'environment__name': attrs.get('environment'),
        }
        if attrs.get('service_id'):
            se_params['service_id'] = attrs['service_id']
            service_selector = attrs['service_id']
        elif attrs.get('service_uid'):
            se_params['service__ci_uid'] = attrs['service_uid']
            service_selector = attrs['service_uid']
        else:
            se_params['service__name'] = attrs['service']
            service_selector = attrs['service']
        try:
            se = ServiceEnvironment.objects.get(**se_params)
        except ServiceEnvironment.DoesNotExist:
            params = ", ".join(
                ["{}={}".format(k, v) for k, v in se_params.items()]
            )
            raise ServiceEnvironmentDoesNotExistError(
                'query params: {}'.format(params)
            )
        return se

    def validate(self, attrs):
        # TODO(xor-xor): Get rid of "non_field_errors" header from error
        # message generated by DjRF.
        # TODO(xor-xor): I'd consider json-schema based approach instead of
        # all of those nested serializers, see:
        # https://richardtier.com/2014/03/24/json-schema-validation-with-django-rest-framework/  # noqa
        # And BTW, I don't really like the idea of validating and filling
        # ("cleaning") attrs both at the same time.
        pricing_obj = attrs.get('pricing_object')
        service = attrs.get('service')
        service_id = attrs.get('service_id')
        service_uid = attrs.get('service_uid')
        env = attrs.get('environment')
        err = None

        # check for the invalid combinations of fields
        if pricing_obj and any((service, service_id, service_uid, env)):
            err = (
                "pricing_object shouldn't be used with any of: service, "
                "service_id, service_uid, environment"
            )
        elif service and any((service_id, service_uid)):
            err = (
                "service shouldn't be used with any of: service_id, "
                "service_uid"
            )
        elif service_id and service_uid:
            err = "service_id shouldn't be used with service_uid"
        elif env and not any((service, service_id, service_uid)):
            err = (
                "environment requires service or service_id or service_uid"
            )
        if err is not None:
            msg = "Invalid combination of fields: {}.".format(err)
            raise serializers.ValidationError(msg)

        # get pricing_object
        if pricing_obj:
            try:
                attrs['pricing_object'] = PricingObject.objects.get(
                    name=pricing_obj
                )
            except PricingObject.DoesNotExist:
                err = "pricing_object {} does not exist".format(pricing_object)
        else:
            try:
                service_env = self._get_service_env(attrs)
            except ServiceEnvironmentDoesNotExistError as e:
                err = (
                    "service environment does not exist ({})".format(e.message)
                )
            attrs['pricing_object'] = service_env.dummy_pricing_object
        if err is not None:
            raise serializers.ValidationError(err)

        return attrs


class PricingServiceUsageObject(object):
    pricing_service = None
    pricing_service_id = None
    date = None
    overwrite = None
    usages = []  # list of UsagesObject

    def __init__(
        self,
        pricing_service=None,
        pricing_service_id=None,
        usages=None,
        date=None,
        overwrite=None,
        **kwargs
    ):
        self.pricing_service = pricing_service
        self.pricing_service_id = pricing_service_id
        self.date = date
        self.usages = usages or []
        self.overwrite = overwrite or 'no'


class PricingServiceUsageObjectSerializer(Serializer):
    pricing_service = serializers.CharField()
    pricing_service_id = serializers.IntegerField()
    date = serializers.DateField()
    overwrite = serializers.CharField()
    usages = UsagesObjectSerializer(many=True)

    class Meta:
        model = PricingServiceUsageObject  # XXX needed..?
        exclude = ('overwrite',)


class PricingServiceUsageObjectDeserializer(PricingServiceUsageObjectSerializer):  # noqa
    overwrite = serializers.CharField(required=False, default='no')
    usages = UsagesObjectDeserializer(many=True)

    def validate_overwrite(self, attrs, source):
        value = attrs[source]
        if value not in ('no', 'delete_all_previous', 'values_only'):
            raise serializers.ValidationError(
                "Invalid value: {}".format(value)
            )
        return attrs

    def validate_pricing_service(self, attrs, source):
        value = attrs[source]
        try:
            PricingService.objects.get(name=value)
        except PricingService.DoesNotExist:
            raise serializers.ValidationError(
                "Unknown service name: {}".format(value)
            )
        return attrs

    class Meta:
        model = PricingServiceUsageObject  # XXX needed..?
        exclude = ('pricing_service_id',)


class PricingServiceUsages(APIView):

    def get(self, request, usages_date, pricing_service_id, *args, **kwargs):
        try:
            PricingService.objects.get(id=pricing_service_id)
        except PricingService.DoesNotExist:
            msg = (
                "Service with ID {} does not exist.".format(pricing_service_id)
            )
            return Response({'error': msg}, status=status.HTTP_400_BAD_REQUEST)
        result = self.get_usages(usages_date, pricing_service_id)
        return Response(PricingServiceUsageObjectSerializer(result).data)

    def post(self, request, *args, **kwargs):
        deserializer = PricingServiceUsageObjectDeserializer(data=request.DATA)
        if deserializer.is_valid():
            self.save_usages(deserializer.object)
            return HttpResponse(status=201)
        return Response(deserializer.errors, status=400)

    def get_usages(self, usages_date, pricing_service_id):
        pricing_service = PricingService.objects.get(
            id=pricing_service_id,
        )
        ps = PricingServiceUsageObject(
            pricing_service=pricing_service.name,
            date=usages_date,
            usages=[],
        )
        usages_dict = defaultdict(list)

        # iterate through pricing service usage types
        for usage_type in pricing_service.usage_types.all():
            daily_usages = usage_type.dailyusage_set.filter(
                date=usages_date
            ).select_related(
                'service_environment',
                'service_environment__service',
                'service_environment__environment',
                'pricing_object'
            )
            for daily_usage in daily_usages:
                usages_dict[daily_usage.daily_pricing_object].append(
                    (daily_usage.type.symbol, daily_usage.value)
                )

        # save usages tp UsagesObjects
        for dpo, u in usages_dict.iteritems():
            usages = UsagesObject()
            se = dpo.service_environment
            usages.service = se.service.name
            usages.service_id = se.service.id
            usages.environment = se.environment.name
            # If pricing object is not a dummy pricing object for given service
            # environment, then use it.
            if se.dummy_pricing_object != dpo.pricing_object:
                usages.pricing_object = dpo.pricing_object.name
            usages.usages = [UsageObject(k, v) for k, v in u]
            ps.usages.append(usages)
        return ps

    def remove_previous_daily_usages(self, overwrite, date, usages_dp_objs):
        if overwrite in ('values_only', 'delete_all_previous'):
            logger.debug('Remove previous values ({})'.format(overwrite))
            for k, v in usages_dp_objs.iteritems():
                previuos_usages = DailyUsage.objects.filter(date=date, type=k)
                if overwrite == 'values_only':
                    previuos_usages = previuos_usages.filter(
                        daily_pricing_object__in=v
                    )
                previuos_usages.delete()

    def save_usages(self, pricing_service_usage):
        logger.info("Saving usages for service {}".format(
            pricing_service_usage['pricing_service']
        ))
        daily_usages, usages_daily_pricing_objects = self.get_usages_for_save(
            pricing_service_usage
        )
        self.remove_previous_daily_usages(
            pricing_service_usage['overwrite'],
            pricing_service_usage['date'],
            usages_daily_pricing_objects,
        )
        DailyUsage.objects.bulk_create(daily_usages)

    def get_usages_for_save(self, pricing_service_usage):
        usage_types_cache = {}
        daily_usages = []
        usages_daily_pricing_objects = defaultdict(list)

        for usages in pricing_service_usage['usages']:
            for usage in usages['usages']:
                usage_type = usage_types_cache.get(
                    usage['symbol'],
                    UsageType.objects.get(symbol=usage['symbol'])
                )
                usage_types_cache[usage['symbol']] = usage_type
                daily_pricing_object = (
                    usages['pricing_object'].get_daily_pricing_object(
                        pricing_service_usage['date']
                    )
                )
                daily_usage = DailyUsage(
                    date=pricing_service_usage['date'],
                    type=usage_type,
                    value=usage['value'],
                    daily_pricing_object=daily_pricing_object,
                    service_environment=(
                        daily_pricing_object.service_environment
                    ),
                )
                daily_usages.append(daily_usage)
                usages_daily_pricing_objects[usage_type].append(
                    daily_pricing_object
                )
        return (daily_usages, usages_daily_pricing_objects)

# -*- coding: utf-8 -*-

from __future__ import absolute_import
from __future__ import division
from __future__ import print_function
from __future__ import unicode_literals

import logging
from collections import defaultdict

from django.http import HttpResponse
from rest_framework import status
from rest_framework import serializers
from rest_framework.views import APIView
from rest_framework.response import Response
from rest_framework.serializers import Serializer

from ralph_scrooge.models import (
    DailyUsage,
    PricingObject,
    PricingService,
    ServiceEnvironment,
    UsageType,
)

logger = logging.getLogger(__name__)


# TODO(xor-xor): Consider moving *all* exceptions used by Scrooge into a single
# module.
class ServiceEnvironmentDoesNotExistError(Exception):
    pass


def new_usage_object(symbol=None, value=None):
    return {
        'symbol': symbol,
        'value': value,
    }


class UsageObjectSerializer(Serializer):
    symbol = serializers.CharField()
    value = serializers.FloatField()


class UsageObjectDeserializer(UsageObjectSerializer):

    def validate_symbol(self, attrs, source):
        if not UsageType.objects.filter(symbol=attrs[source]).exists():
            err = (
                'usage type for symbol "{}" does not exist'
                .format(attrs[source])
            )
            raise serializers.ValidationError(err)
        return attrs


def new_usages_object(
        service=None,
        service_id=None,
        environment=None,
        pricing_object=None,
        usages=None,
):
    return {
        'service': service,
        'service_id': service_id,
        'environment': environment,
        'pricing_object': pricing_object,
        'usages': usages or [],
    }


class UsagesObjectSerializer(Serializer):
    service = serializers.CharField()
    service_id = serializers.IntegerField()
    environment = serializers.CharField()
    pricing_object = serializers.CharField()
    usages = UsageObjectSerializer(many=True)


class UsagesObjectDeserializer(UsagesObjectSerializer):
    service = serializers.CharField(required=False)
    service_id = serializers.IntegerField(required=False)
    service_uid = serializers.CharField(required=False)
    environment = serializers.CharField(required=False)
    pricing_object = serializers.CharField(required=False)
    usages = UsageObjectDeserializer(many=True)

    def _get_service_env(self, attrs):
        se_params = {
            'environment__name': attrs.get('environment'),
        }
        if attrs.get('service_id'):
            se_params['service_id'] = attrs['service_id']
        elif attrs.get('service_uid'):
            se_params['service__ci_uid'] = attrs['service_uid']
        else:
            se_params['service__name'] = attrs['service']
        try:
            se = ServiceEnvironment.objects.get(**se_params)
        except ServiceEnvironment.DoesNotExist:
            params = ", ".join(
                ["{}={}".format(k, v) for k, v in se_params.items()]
            )
            raise ServiceEnvironmentDoesNotExistError(
                'query params: {}'.format(params)
            )
        return se

    def validate(self, attrs):
        # TODO(xor-xor): Get rid of "non_field_errors" header from error
        # message generated by DjRF.
        # TODO(xor-xor): I'd consider json-schema based approach instead of
        # all of those nested serializers, see:
        # https://richardtier.com/2014/03/24/json-schema-validation-with-django-rest-framework/  # noqa
        # And BTW, I don't really like the idea of validating and filling
        # ("cleaning") attrs both at the same time.
        pricing_obj = attrs.get('pricing_object')
        service = attrs.get('service')
        service_id = attrs.get('service_id')
        service_uid = attrs.get('service_uid')
        env = attrs.get('environment')
        err = None

        # check for the invalid combinations of fields
        if pricing_obj and any((service, service_id, service_uid, env)):
            err = (
                "pricing_object shouldn't be used with any of: service, "
                "service_id, service_uid, environment"
            )
        elif service and any((service_id, service_uid)):
            err = (
                "service shouldn't be used with any of: service_id, "
                "service_uid"
            )
        elif service_id and service_uid:
            err = "service_id shouldn't be used with service_uid"
        elif env and not any((service, service_id, service_uid)):
            err = (
                "environment requires service or service_id or service_uid"
            )
        if err is not None:
            msg = "Invalid combination of fields: {}.".format(err)
            raise serializers.ValidationError(msg)

        # get pricing_object
        if pricing_obj:
            try:
                attrs['pricing_object'] = PricingObject.objects.get(
                    name=pricing_obj
                )
            except PricingObject.DoesNotExist:
                err = "pricing_object {} does not exist".format(pricing_obj)
        else:
            try:
                service_env = self._get_service_env(attrs)
            except ServiceEnvironmentDoesNotExistError as e:
                err = (
                    "service environment does not exist ({})".format(e.message)
                )
            attrs['pricing_object'] = service_env.dummy_pricing_object
        if err is not None:
            raise serializers.ValidationError(err)

        return attrs


PRICING_SERVICE_USAGE_OBJECT = {
    'pricing_service': None,
    'pricing_service_id': None,
    'date': None,
    'overwrite': 'no',
    'usages': [],
}


def new_pricing_service_usage_object(
        pricing_service=None,
        pricing_service_id=None,
        usages=None,
        date=None,
        overwrite='no',
):
    return {
        'pricing_service': pricing_service,
        'pricing_service_id': pricing_service_id,
        'usages': usages or [],
        'date': date,
        'overwrite': overwrite,
    }


class PricingServiceUsageObjectSerializer(Serializer):
    pricing_service = serializers.CharField()
    pricing_service_id = serializers.IntegerField()
    date = serializers.DateField()
    usages = UsagesObjectSerializer(many=True)


class PricingServiceUsageObjectDeserializer(PricingServiceUsageObjectSerializer):  # noqa
    pricing_service_id = serializers.IntegerField(required=False)
    overwrite = serializers.CharField(required=False, default='no')
    usages = UsagesObjectDeserializer(many=True)

    def validate_overwrite(self, attrs, source):
        value = attrs[source]
        if value not in ('no', 'delete_all_previous', 'values_only'):
            raise serializers.ValidationError(
                "Invalid value: {}".format(value)
            )
        return attrs

    def validate_pricing_service(self, attrs, source):
        value = attrs[source]
        try:
            PricingService.objects.get(name=value)
        except PricingService.DoesNotExist:
            raise serializers.ValidationError(
                "Unknown service name: {}".format(value)
            )
        return attrs


class PricingServiceUsages(APIView):

    # TODO(xor-xor): Consider using function-based views / api_view decorator
    # to get rid of this logic here (and allowed_methods extra argument in
    # definition of URLs).
    def dispatch(self, request, allowed_methods=[], *args, **kwargs):
        if request.method not in allowed_methods:
            return HttpResponse(status=405)
        return super(PricingServiceUsages, self).dispatch(
            request, *args, **kwargs
        )

    def get(self, request, usages_date, pricing_service_id, *args, **kwargs):
        try:
            PricingService.objects.get(id=pricing_service_id)
        except PricingService.DoesNotExist:
            msg = (
                "Service with ID {} does not exist.".format(pricing_service_id)
            )
            return Response({'error': msg}, status=status.HTTP_400_BAD_REQUEST)
        result = self.get_usages(usages_date, pricing_service_id)
        return Response(PricingServiceUsageObjectSerializer(result).data)

    def get_usages(self, usages_date, pricing_service_id):
        pricing_service = PricingService.objects.get(
            id=pricing_service_id,
        )
        ps = new_pricing_service_usage_object(
            pricing_service=pricing_service.name,
            date=usages_date,
        )
        usages_dict = defaultdict(list)

        # iterate through pricing service usage types
        for usage_type in pricing_service.usage_types.all():
            daily_usages = usage_type.dailyusage_set.filter(
                date=usages_date
            ).select_related(
                'service_environment',
                'service_environment__service',
                'service_environment__environment',
                'pricing_object'
            )
            for daily_usage in daily_usages:
                usages_dict[daily_usage.daily_pricing_object].append(
                    (daily_usage.type.symbol, daily_usage.value)
                )

        # save usages to UsagesObjects
        for dpo, u in usages_dict.iteritems():
            se = dpo.service_environment
            usages = new_usages_object(
                service=se.service.name,
                service_id=se.service.id,
                environment=se.environment.name,
            )
            # If pricing object is not a dummy pricing object for given service
            # environment, then use it.
            if se.dummy_pricing_object != dpo.pricing_object:
                usages['pricing_object'] = dpo.pricing_object.name
            usages['usages'] = [
                new_usage_object(symbol=k, value=v) for k, v in u
            ]
            ps['usages'].append(usages)
        return ps

    def post(self, request, *args, **kwargs):
        deserializer = PricingServiceUsageObjectDeserializer(data=request.DATA)
        if deserializer.is_valid():
            self.save_usages(deserializer.object)
            return HttpResponse(status=201)
        return Response(deserializer.errors, status=400)

    def save_usages(self, pricing_service_usage):
        logger.info("Saving usages for service {}".format(
            pricing_service_usage['pricing_service']
        ))
        daily_usages, usages_daily_pricing_objects = self.get_usages_for_save(
            pricing_service_usage
        )
        self.remove_previous_daily_usages(
            pricing_service_usage['overwrite'],
            pricing_service_usage['date'],
            usages_daily_pricing_objects,
        )
        DailyUsage.objects.bulk_create(daily_usages)

    def get_usages_for_save(self, pricing_service_usage):
        usage_types_cache = {}
        daily_usages = []
        usages_daily_pricing_objects = defaultdict(list)

        for usages in pricing_service_usage['usages']:
            for usage in usages['usages']:
                usage_type = usage_types_cache.get(
                    usage['symbol'],
                    UsageType.objects.get(symbol=usage['symbol'])
                )
                usage_types_cache[usage['symbol']] = usage_type
                daily_pricing_object = (
                    usages['pricing_object'].get_daily_pricing_object(
                        pricing_service_usage['date']
                    )
                )
                daily_usage = DailyUsage(
                    date=pricing_service_usage['date'],
                    type=usage_type,
                    value=usage['value'],
                    daily_pricing_object=daily_pricing_object,
                    service_environment=(
                        daily_pricing_object.service_environment
                    ),
                )
                daily_usages.append(daily_usage)
                usages_daily_pricing_objects[usage_type].append(
                    daily_pricing_object
                )
        return (daily_usages, usages_daily_pricing_objects)

    def remove_previous_daily_usages(self, overwrite, date, usages_dp_objs):
        if overwrite in ('values_only', 'delete_all_previous'):
            logger.debug('Remove previous values ({})'.format(overwrite))
            for k, v in usages_dp_objs.iteritems():
                previous_usages = DailyUsage.objects.filter(date=date, type=k)
                if overwrite == 'values_only':
                    previous_usages = previous_usages.filter(
                        daily_pricing_object__in=v
                    )
                previous_usages.delete()
